#!/usr/bin/pythonfrom time import sleepimport syslog, threadinglock = threading.Lock()def task_box_telemetry(Periode):	TB_Token = 'http://thingsboard.kbw-cloud.de/api/v1/box008/telemetry'	import math	import paho.mqtt.publish as publish	import psutil	import requests	import subprocess	def kiloMegaGiga(x):		f = [[1, ''], [1e3, 'k'], [1e6, 'M'], [1e9, 'G']]		i = max(0, min(3, int(math.log10(x) // 3)))		return f'{x / f[i][0]:.1f} {f[i][1]}'	while 1:		with lock:			if 200 == requests.get('http://10.8.0.1:8055', timeout=5).status_code:				publish.single('LED_VPN', 1)				data = {					'IP VPN'            : psutil.net_if_addrs().get('tun0', [''])[0].address,					'WLAN LTE Status'   : subprocess.check_output("ssid=$(iwgetid -r)||ssid='no';echo $ssid",										      shell=True).decode().strip(),					'CPU Temperatur, °C': subprocess.check_output(['vcgencmd', 'measure_temp']).decode()[5:-3],					'CPU Usage, %'      : psutil.cpu_percent(interval=1),					'Free RAM'          : kiloMegaGiga(psutil.virtual_memory().free) + 'b',					'Free Disk'         : kiloMegaGiga(psutil.disk_usage('.').free) + 'b'				}				# nach ThingsBoard senden				response = requests.post(TB_Token, data=str(data).encode('utf-8'),							 timeout=5, headers={'Content-Type': 'application/json; charset=UTF-8'})				if 200 != response.status_code:					syslog.syslog(syslog.LOG_WARNING, f'Error sending nach TB {response.status_code}')			else:				publish.single('LED_VPN', 0)			#syslog.syslog(syslog.LOG_INFO, 'box telemetry')		sleep(Periode)def task_opc(Periode):	node = {		'Tanktemp'    : 2,		'Tankniveau'  : 3,		'Volumenstrom': 4,	}	opc = 'opc.tcp://192.168.10.123:4840'	db_name = 'telemetry'	measurement = 'opc'	from influxdb import InfluxDBClient	from opcua import Client	with lock:		# connect influx		InfluxClient = InfluxDBClient()		# use telemetry		InfluxClient.switch_database(db_name)		# connect opc		OpcClient = Client(opc)		OpcClient.session_timeout = 1000		OpcClient.connect()	while 1:		with lock:			InfluxClient.write_points([{'measurement': measurement, 'fields': {k: OpcClient.get_node(f'ns=4;i={v}').get_value() for k, v in node.items()}}])		sleep(Periode)		#syslog.syslog(syslog.LOG_INFO, 'opc')def task_influx(Periode):	# von db	db_name = 'telemetry'	# berechne Mittelwerte	Mittelwerte = ['Tanktemp', 'Tankniveau', 'Volumenstrom']	# senden nach ThingsBoardToken	ThingsBoardToken = 'http://thingsboard.kbw-cloud.de/api/v1/box008/telemetry'	TimeZone = 'Europe/Berlin'	# berechnen alle Mittelwerte (max 60 voraussichtlich)	Query1 = f"SELECT {', '.join([f'MEAN({a}) AS {a}' for a in Mittelwerte])} FROM opc GROUP BY time({Periode}s) fill(none) LIMIT 60"	# holen 2 letzte Mittelwerte	Query2 = f"SELECT {', '.join([f'MEAN({a}) AS {a}' for a in Mittelwerte])} FROM opc GROUP BY time({Periode}s) fill(none) ORDER BY time DESC LIMIT 2"	from datetime import datetime	from influxdb import InfluxDBClient	import pytz	import requests	def local_timestamp(ts, timezone):		dt = datetime.strptime(ts, '%Y-%m-%dT%H:%M:%SZ').replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(timezone))		return 1000*int(dt.timestamp())	with lock:		# connect influx		InfluxClient = InfluxDBClient()		# use telemetry		InfluxClient.switch_database(db_name)	data=[]	with lock:		for values in InfluxClient.query(Query1).get_points():			ts = values.pop('time')			data.append({"ts": local_timestamp(ts, TimeZone), "values": values})	while True:		# nach ThingsBoard senden		with lock:			response = requests.post(ThingsBoardToken, data=str(data).encode('utf-8'),									 timeout=5, headers={'Content-Type': 'application/json; charset=UTF-8'})			if 200 != response.status_code:				syslog.syslog(syslog.LOG_WARNING, f'Error sending nach TB {response.status_code}')		sleep(Periode)		#syslog.syslog(syslog.LOG_INFO, 'influx')		data = []		with lock:			for values in InfluxClient.query(Query2).get_points():				ts = values.pop('time')				data.append({"ts": local_timestamp(ts, TimeZone), "values": values})def task_wifi(Periode):	wifi = {		'Besucher' : 'Willkommen!',		'FB-Gast'  : 'qsj5eKuabwPuggKj24s0dNMN*UtlbgjgXG5075v0sskZvjA==*FF/odSuopI35zUQEG+kjzg==*d6IzKVchaHY9xcpferDt2A==',		'GastTest' : 'FjQUFOijPB4=*G6ktgEkXqWboPlDL84vaAw==*QgyI5do8kED4Magjo4aeBg==*LbKgdhhmUF59D8zMUDpP0A==',		'KBWIIOT'  : 'US9P9PbmMKuibE8=*T/BNGi06TVcyMCRP4pSrHQ==*2KFeDMbJKHCHOOy+r72jRw==*gEjVsLx5AxmdsliFkdLP5A==',		'Schi01'   : 'FjQUFOijPB4=*G6ktgEkXqWboPlDL84vaAw==*QgyI5do8kED4Magjo4aeBg==*LbKgdhhmUF59D8zMUDpP0A==',		'matrixSCI': 'mE3nG0o+V7feCyAxDxqVgjQ=*jummKSJRpzClAblFqzjhKA==*H3mj1PZBjvawqwSt2AlgXQ==*RUWfuHFYSh9xMj7xaJZtrg==',	}	import cryptocode	import re	import subprocess	def decode(passw):		if len(passw) > 20:			passw = cryptocode.decrypt(passw, 'Kbwiot2022!')		return passw	def nmcli_c():		return subprocess.check_output("nmcli c | awk '/wifi/ {print $1}'", shell=True).decode().split()	def nmcli_add(ssid, passw):		subprocess.run(['nmcli', 'con', 'add', 'ifname', 'wlan0', 'con-name', ssid, 'type', 'wifi', 'ssid', ssid,				'ipv4.route-metric', '150', 'wifi-sec.key-mgmt', 'wpa-psk', 'wifi-sec.psk', passw])	def nmcli_del(datei):		subprocess.run(['nmcli', 'connection', 'delete', datei])	def hat(datei, ssid, passw):		pat = re.compile(f'(ssid={ssid}$).+(psk={passw}$)', re.M+re.S)		try:			with open(f'/etc/NetworkManager/system-connections/{datei}.nmconnection') as file:				return pat.findall(file.read())		except:			return []	while 1:		with lock:			for datei in set(nmcli_c()).difference(set(wifi.keys())):				nmcli_del(datei)			for datei in nmcli_c():				flag = True				for ssid, passw in wifi.items():					if hat(datei, ssid, decode(passw)):						flag = False						break				if flag:					nmcli_del(datei)			for ssid in set(wifi.keys()).difference(set(nmcli_c())):				nmcli_add(ssid, decode(wifi[ssid]))		sleep(Periode)# Threads für jede Aufgabepool = [	threading.Thread(target=task_box_telemetry, args=(120,)),	threading.Thread(target=task_opc, args=(1,)),	threading.Thread(target=task_influx, args=(60,)),	threading.Thread(target=task_wifi, args=(100000,)),][t.start() for t in pool]while all([t.is_alive() for t in pool]):	sleep(60)syslog.syslog(syslog.LOG_WARNING, 'Einige Threads wurden in tasks.py gestoppt.')